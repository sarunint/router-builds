{"version":3,"file":"activate_routes.js","sourceRoot":"","sources":["../../../../../packages/router/src/operators/activate_routes.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {MonoTypeOperatorFunction} from 'rxjs';\nimport {map} from 'rxjs/operators';\n\nimport {LoadedRouterConfig} from '../config';\nimport {ActivationEnd, ChildActivationEnd, Event} from '../events';\nimport {DetachedRouteHandleInternal, RouteReuseStrategy} from '../route_reuse_strategy';\nimport {NavigationTransition} from '../router';\nimport {ChildrenOutletContexts} from '../router_outlet_context';\nimport {ActivatedRoute, ActivatedRouteSnapshot, RouterState, advanceActivatedRoute} from '../router_state';\nimport {forEach} from '../utils/collection';\nimport {TreeNode, nodeChildrenAsMap} from '../utils/tree';\n\nexport const activateRoutes =\n    (rootContexts: ChildrenOutletContexts, routeReuseStrategy: RouteReuseStrategy,\n     forwardEvent: (evt: Event) => void): MonoTypeOperatorFunction<NavigationTransition> =>\n        map(t => {\n          new ActivateRoutes(\n              routeReuseStrategy, t.targetRouterState !, t.currentRouterState, forwardEvent)\n              .activate(rootContexts);\n          return t;\n        });\n\nexport class ActivateRoutes {\n  constructor(\n      private routeReuseStrategy: RouteReuseStrategy, private futureState: RouterState,\n      private currState: RouterState, private forwardEvent: (evt: Event) => void) {}\n\n  activate(parentContexts: ChildrenOutletContexts): void {\n    const futureRoot = this.futureState._root;\n    const currRoot = this.currState ? this.currState._root : null;\n\n    this.deactivateChildRoutes(futureRoot, currRoot, parentContexts);\n    advanceActivatedRoute(this.futureState.root);\n    this.activateChildRoutes(futureRoot, currRoot, parentContexts);\n  }\n\n  // De-activate the child route that are not re-used for the future state\n  private deactivateChildRoutes(\n      futureNode: TreeNode<ActivatedRoute>, currNode: TreeNode<ActivatedRoute>|null,\n      contexts: ChildrenOutletContexts): void {\n    const children: {[outletName: string]: TreeNode<ActivatedRoute>} = nodeChildrenAsMap(currNode);\n\n    // Recurse on the routes active in the future state to de-activate deeper children\n    futureNode.children.forEach(futureChild => {\n      const childOutletName = futureChild.value.outlet;\n      this.deactivateRoutes(futureChild, children[childOutletName], contexts);\n      delete children[childOutletName];\n    });\n\n    // De-activate the routes that will not be re-used\n    forEach(children, (v: TreeNode<ActivatedRoute>, childName: string) => {\n      this.deactivateRouteAndItsChildren(v, contexts);\n    });\n  }\n\n  private deactivateRoutes(\n      futureNode: TreeNode<ActivatedRoute>, currNode: TreeNode<ActivatedRoute>,\n      parentContext: ChildrenOutletContexts): void {\n    const future = futureNode.value;\n    const curr = currNode ? currNode.value : null;\n\n    if (future === curr) {\n      // Reusing the node, check to see if the children need to be de-activated\n      if (future.component) {\n        // If we have a normal route, we need to go through an outlet.\n        const context = parentContext.getContext(future.outlet);\n        if (context) {\n          this.deactivateChildRoutes(futureNode, currNode, context.children);\n        }\n      } else {\n        // if we have a componentless route, we recurse but keep the same outlet map.\n        this.deactivateChildRoutes(futureNode, currNode, parentContext);\n      }\n    } else {\n      if (curr) {\n        // Deactivate the current route which will not be re-used\n        this.deactivateRouteAndItsChildren(currNode, parentContext);\n      }\n    }\n  }\n\n  private deactivateRouteAndItsChildren(\n      route: TreeNode<ActivatedRoute>, parentContexts: ChildrenOutletContexts): void {\n    if (this.routeReuseStrategy.shouldDetach(route.value.snapshot)) {\n      this.detachAndStoreRouteSubtree(route, parentContexts);\n    } else {\n      this.deactivateRouteAndOutlet(route, parentContexts);\n    }\n  }\n\n  private detachAndStoreRouteSubtree(\n      route: TreeNode<ActivatedRoute>, parentContexts: ChildrenOutletContexts): void {\n    const context = parentContexts.getContext(route.value.outlet);\n    if (context && context.outlet) {\n      const componentRef = context.outlet.detach();\n      const contexts = context.children.onOutletDeactivated();\n      this.routeReuseStrategy.store(route.value.snapshot, {componentRef, route, contexts});\n    }\n  }\n\n  private deactivateRouteAndOutlet(\n      route: TreeNode<ActivatedRoute>, parentContexts: ChildrenOutletContexts): void {\n    const context = parentContexts.getContext(route.value.outlet);\n\n    if (context) {\n      const children: {[outletName: string]: any} = nodeChildrenAsMap(route);\n      const contexts = route.value.component ? context.children : parentContexts;\n\n      forEach(children, (v: any, k: string) => this.deactivateRouteAndItsChildren(v, contexts));\n\n      if (context.outlet) {\n        // Destroy the component\n        context.outlet.deactivate();\n        // Destroy the contexts for all the outlets that were in the component\n        context.children.onOutletDeactivated();\n      }\n    }\n  }\n\n  private activateChildRoutes(\n      futureNode: TreeNode<ActivatedRoute>, currNode: TreeNode<ActivatedRoute>|null,\n      contexts: ChildrenOutletContexts): void {\n    const children: {[outlet: string]: any} = nodeChildrenAsMap(currNode);\n    futureNode.children.forEach(c => {\n      this.activateRoutes(c, children[c.value.outlet], contexts);\n      this.forwardEvent(new ActivationEnd(c.value.snapshot));\n    });\n    if (futureNode.children.length) {\n      this.forwardEvent(new ChildActivationEnd(futureNode.value.snapshot));\n    }\n  }\n\n  private activateRoutes(\n      futureNode: TreeNode<ActivatedRoute>, currNode: TreeNode<ActivatedRoute>,\n      parentContexts: ChildrenOutletContexts): void {\n    const future = futureNode.value;\n    const curr = currNode ? currNode.value : null;\n\n    advanceActivatedRoute(future);\n\n    // reusing the node\n    if (future === curr) {\n      if (future.component) {\n        // If we have a normal route, we need to go through an outlet.\n        const context = parentContexts.getOrCreateContext(future.outlet);\n        this.activateChildRoutes(futureNode, currNode, context.children);\n      } else {\n        // if we have a componentless route, we recurse but keep the same outlet map.\n        this.activateChildRoutes(futureNode, currNode, parentContexts);\n      }\n    } else {\n      if (future.component) {\n        // if we have a normal route, we need to place the component into the outlet and recurse.\n        const context = parentContexts.getOrCreateContext(future.outlet);\n\n        if (this.routeReuseStrategy.shouldAttach(future.snapshot)) {\n          const stored =\n              (<DetachedRouteHandleInternal>this.routeReuseStrategy.retrieve(future.snapshot));\n          this.routeReuseStrategy.store(future.snapshot, null);\n          context.children.onOutletReAttached(stored.contexts);\n          context.attachRef = stored.componentRef;\n          context.route = stored.route.value;\n          if (context.outlet) {\n            // Attach right away when the outlet has already been instantiated\n            // Otherwise attach from `RouterOutlet.ngOnInit` when it is instantiated\n            context.outlet.attach(stored.componentRef, stored.route.value);\n          }\n          advanceActivatedRouteNodeAndItsChildren(stored.route);\n        } else {\n          const config = parentLoadedConfig(future.snapshot);\n          const cmpFactoryResolver = config ? config.module.componentFactoryResolver : null;\n\n          context.attachRef = null;\n          context.route = future;\n          context.resolver = cmpFactoryResolver;\n          if (context.outlet) {\n            // Activate the outlet when it has already been instantiated\n            // Otherwise it will get activated from its `ngOnInit` when instantiated\n            context.outlet.activateWith(future, cmpFactoryResolver);\n          }\n\n          this.activateChildRoutes(futureNode, null, context.children);\n        }\n      } else {\n        // if we have a componentless route, we recurse but keep the same outlet map.\n        this.activateChildRoutes(futureNode, null, parentContexts);\n      }\n    }\n  }\n}\n\nfunction advanceActivatedRouteNodeAndItsChildren(node: TreeNode<ActivatedRoute>): void {\n  advanceActivatedRoute(node.value);\n  node.children.forEach(advanceActivatedRouteNodeAndItsChildren);\n}\n\nfunction parentLoadedConfig(snapshot: ActivatedRouteSnapshot): LoadedRouterConfig|null {\n  for (let s = snapshot.parent; s; s = s.parent) {\n    const route = s.routeConfig;\n    if (route && route._loadedConfig) return route._loadedConfig;\n    if (route && route.component) return null;\n  }\n\n  return null;\n}"]}