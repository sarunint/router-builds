{"version":3,"file":"switch_tap.js","sourceRoot":"","sources":["../../../../../packages/router/src/operators/switch_tap.ts"],"names":[],"mappings":";;;;;;;;;;;AAQA,OAAO,EAA4C,IAAI,EAAC,MAAM,MAAM,CAAC;AACrE,OAAO,EAAC,GAAG,EAAE,SAAS,EAAC,MAAM,gBAAgB,CAAC;;;;;;;;;;AAQ9C,MAAM,UAAU,SAAS,CAAI,IAAyC;IAEpE,OAAO,UAAS,MAAM;QACpB,OAAO,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,EAAE;;YAC/B,MAAM,UAAU,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;YAC3B,IAAI,UAAU,EAAE;gBACd,OAAO,IAAI,CAAC,UAAU,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;aAC5C;YACD,OAAO,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;SAClB,CAAC,CAAC,CAAC;KACL,CAAC;CACH","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {MonoTypeOperatorFunction, ObservableInput, from} from 'rxjs';\nimport {map, switchMap} from 'rxjs/operators';\n\n/**\n * Perform a side effect through a switchMap for every emission on the source Observable,\n * but return an Observable that is identical to the source. It's essentially the same as\n * the `tap` operator, but if the side effectful `next` function returns an ObservableInput,\n * it will wait before continuing with the original value.\n */\nexport function switchTap<T>(next: (x: T) => void|ObservableInput<any>):\n    MonoTypeOperatorFunction<T> {\n  return function(source) {\n    return source.pipe(switchMap(v => {\n      const nextResult = next(v);\n      if (nextResult) {\n        return from(nextResult).pipe(map(() => v));\n      }\n      return from([v]);\n    }));\n  };\n}\n"]}