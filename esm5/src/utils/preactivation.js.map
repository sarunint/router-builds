{"version":3,"file":"preactivation.js","sourceRoot":"","sources":["../../../../../../packages/router/src/utils/preactivation.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injector} from '@angular/core';\n\nimport {LoadedRouterConfig, RunGuardsAndResolvers} from '../config';\nimport {ChildrenOutletContexts, OutletContext} from '../router_outlet_context';\nimport {ActivatedRouteSnapshot, RouterStateSnapshot, equalParamsAndUrlSegments} from '../router_state';\nimport {forEach, shallowEqual} from '../utils/collection';\nimport {TreeNode, nodeChildrenAsMap} from '../utils/tree';\n\nexport class CanActivate {\n  readonly route: ActivatedRouteSnapshot;\n  constructor(public path: ActivatedRouteSnapshot[]) {\n    this.route = this.path[this.path.length - 1];\n  }\n}\n\nexport class CanDeactivate {\n  constructor(public component: Object|null, public route: ActivatedRouteSnapshot) {}\n}\n\nexport declare type Checks = {\n  canDeactivateChecks: CanDeactivate[],\n  canActivateChecks: CanActivate[],\n};\n\nexport function getAllRouteGuards(\n    future: RouterStateSnapshot, curr: RouterStateSnapshot,\n    parentContexts: ChildrenOutletContexts) {\n  const futureRoot = future._root;\n  const currRoot = curr ? curr._root : null;\n\n  return getChildRouteGuards(futureRoot, currRoot, parentContexts, [futureRoot.value]);\n}\n\nexport function getCanActivateChild(p: ActivatedRouteSnapshot):\n    {node: ActivatedRouteSnapshot, guards: any[]}|null {\n  const canActivateChild = p.routeConfig ? p.routeConfig.canActivateChild : null;\n  if (!canActivateChild || canActivateChild.length === 0) return null;\n  return {node: p, guards: canActivateChild};\n}\n\nexport function getToken(\n    token: any, snapshot: ActivatedRouteSnapshot, moduleInjector: Injector): any {\n  const config = getClosestLoadedConfig(snapshot);\n  const injector = config ? config.module.injector : moduleInjector;\n  return injector.get(token);\n}\n\nfunction getClosestLoadedConfig(snapshot: ActivatedRouteSnapshot): LoadedRouterConfig|null {\n  if (!snapshot) return null;\n\n  for (let s = snapshot.parent; s; s = s.parent) {\n    const route = s.routeConfig;\n    if (route && route._loadedConfig) return route._loadedConfig;\n  }\n\n  return null;\n}\n\nfunction getChildRouteGuards(\n    futureNode: TreeNode<ActivatedRouteSnapshot>, currNode: TreeNode<ActivatedRouteSnapshot>| null,\n    contexts: ChildrenOutletContexts | null, futurePath: ActivatedRouteSnapshot[],\n    checks: Checks = {\n      canDeactivateChecks: [],\n      canActivateChecks: []\n    }): Checks {\n  const prevChildren = nodeChildrenAsMap(currNode);\n\n  // Process the children of the future route\n  futureNode.children.forEach(c => {\n    getRouteGuards(c, prevChildren[c.value.outlet], contexts, futurePath.concat([c.value]), checks);\n    delete prevChildren[c.value.outlet];\n  });\n\n  // Process any children left from the current route (not active for the future route)\n  forEach(\n      prevChildren, (v: TreeNode<ActivatedRouteSnapshot>, k: string) =>\n                        deactivateRouteAndItsChildren(v, contexts !.getContext(k), checks));\n\n  return checks;\n}\n\nfunction getRouteGuards(\n    futureNode: TreeNode<ActivatedRouteSnapshot>, currNode: TreeNode<ActivatedRouteSnapshot>,\n    parentContexts: ChildrenOutletContexts | null, futurePath: ActivatedRouteSnapshot[],\n    checks: Checks = {\n      canDeactivateChecks: [],\n      canActivateChecks: []\n    }): Checks {\n  const future = futureNode.value;\n  const curr = currNode ? currNode.value : null;\n  const context = parentContexts ? parentContexts.getContext(futureNode.value.outlet) : null;\n\n  // reusing the node\n  if (curr && future.routeConfig === curr.routeConfig) {\n    const shouldRun =\n        shouldRunGuardsAndResolvers(curr, future, future.routeConfig !.runGuardsAndResolvers);\n    if (shouldRun) {\n      checks.canActivateChecks.push(new CanActivate(futurePath));\n    } else {\n      // we need to set the data\n      future.data = curr.data;\n      future._resolvedData = curr._resolvedData;\n    }\n\n    // If we have a component, we need to go through an outlet.\n    if (future.component) {\n      getChildRouteGuards(\n          futureNode, currNode, context ? context.children : null, futurePath, checks);\n\n      // if we have a componentless route, we recurse but keep the same outlet map.\n    } else {\n      getChildRouteGuards(futureNode, currNode, parentContexts, futurePath, checks);\n    }\n\n    if (shouldRun) {\n      const component = context && context.outlet && context.outlet.component || null;\n      checks.canDeactivateChecks.push(new CanDeactivate(component, curr));\n    }\n  } else {\n    if (curr) {\n      deactivateRouteAndItsChildren(currNode, context, checks);\n    }\n\n    checks.canActivateChecks.push(new CanActivate(futurePath));\n    // If we have a component, we need to go through an outlet.\n    if (future.component) {\n      getChildRouteGuards(futureNode, null, context ? context.children : null, futurePath, checks);\n\n      // if we have a componentless route, we recurse but keep the same outlet map.\n    } else {\n      getChildRouteGuards(futureNode, null, parentContexts, futurePath, checks);\n    }\n  }\n\n  return checks;\n}\n\nfunction shouldRunGuardsAndResolvers(\n    curr: ActivatedRouteSnapshot, future: ActivatedRouteSnapshot,\n    mode: RunGuardsAndResolvers | undefined): boolean {\n  switch (mode) {\n    case 'always':\n      return true;\n\n    case 'paramsOrQueryParamsChange':\n      return !equalParamsAndUrlSegments(curr, future) ||\n          !shallowEqual(curr.queryParams, future.queryParams);\n\n    case 'paramsChange':\n    default:\n      return !equalParamsAndUrlSegments(curr, future);\n  }\n}\n\nfunction deactivateRouteAndItsChildren(\n    route: TreeNode<ActivatedRouteSnapshot>, context: OutletContext | null, checks: Checks): void {\n  const children = nodeChildrenAsMap(route);\n  const r = route.value;\n\n  forEach(children, (node: TreeNode<ActivatedRouteSnapshot>, childName: string) => {\n    if (!r.component) {\n      deactivateRouteAndItsChildren(node, context, checks);\n    } else if (context) {\n      deactivateRouteAndItsChildren(node, context.children.getContext(childName), checks);\n    } else {\n      deactivateRouteAndItsChildren(node, null, checks);\n    }\n  });\n\n  if (!r.component) {\n    checks.canDeactivateChecks.push(new CanDeactivate(null, r));\n  } else if (context && context.outlet && context.outlet.isActivated) {\n    checks.canDeactivateChecks.push(new CanDeactivate(context.outlet.component, r));\n  } else {\n    checks.canDeactivateChecks.push(new CanDeactivate(null, r));\n  }\n}\n"]}